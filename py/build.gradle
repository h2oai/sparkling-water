description = "PySparkling - Sparkling Water Python Package"

apply from: "$rootDir/gradle/utils.gradle"
apply plugin: 'ru.vyarus.use-python'

import ru.vyarus.gradle.plugin.python.cmd.Python

def getPythonVersion() {
  Python p = new Python(project, python.getPythonPath(), python.getPythonBinary())
  return p.version
}

ext {
  FS = File.separator
  FPS = File.pathSeparator
  pythonBinary = findProperty("pythonBinary") ?: "python"
  pkgDir = file("$buildDir/pkg")
  distDir = file("$buildDir/dist")
  condaDir = file("$buildDir/conda/h2o_pysparkling_${sparkMajorVersion}")
  wheelFile = file("${rootDir}/.gradle/wheels/h2o-${h2oMajorVersion}.${h2oBuild}-py2.py3-none-any.whl")
}

// Define the environment required to run tests
python {
  if (project.hasProperty("pythonBinary")) {
    pythonBinary project.findProperty("pythonBinary").toString()
  }
  if (project.hasProperty("pythonPath")) {
    pythonPath project.findProperty("pythonPath").toString()
  }
  String pythonVersionWithoutPatchPart = pythonVersion.substring(0, pythonVersion.lastIndexOf('.'))
  String numpyVersion = numpyVersions.get(pythonVersionWithoutPatchPart, numpyVersions.get("default"))

  pip "pytz:2023.3.post1" // Needed in Integration tests, but not PySparkling dependency
  pip "pytest:6.2.5"
  pip "tabulate:0.8.10"
  pip "requests:2.27.1"
  pip "numpy:${numpyVersion}"
  pip "pyspark:${sparkVersion}"
  if (project.hasProperty("pythonEnvBasePath")) {
    // for CI as we use pre-cached environment
    envPath "${project.findProperty("pythonEnvBasePath")}/${getPythonVersion()}/${sparkVersion}"
  } else {
    envPath "${rootDir}/.gradle/python/${getPythonVersion()}/${sparkVersion}"
  }
}

configurations {
  sparklingWaterAssemblyJar
  apiGeneration
}

dependencies {
  sparklingWaterAssemblyJar project(path: ':sparkling-water-assembly', configuration: 'shadow')
  apiGeneration "org.scala-lang:scala-library:${scalaVersion}"
  apiGeneration project(path: ':sparkling-water-api-generation', configuration: 'shadow')
  apiGeneration project(path: ':sparkling-water-assembly', configuration: 'shadow')
  apiGeneration "org.apache.spark:spark-repl_${scalaBaseVersion}:${sparkVersion}"
}

//
// Create a file with version for Python dist task
//
task createVersionFile {
  doLast {
    def versionFileDir = new File(pkgDir, "ai/h2o/sparkling")
    if (!versionFileDir.exists()) {
      versionFileDir.mkdirs()
    }
    File version_file = new File(versionFileDir, "version.txt")

    def version_txt = version
    version_file.write(version_txt)
  }
}

//
// Represents a location of H2O Wheel Package
//
def h2oPythonWheelPackageLocation() {
  def suffix = "${h2oBuild}/Python/h2o-${h2oMajorVersion}.${h2oBuild}-py2.py3-none-any.whl"
  def prefix = "http://h2o-release.s3.amazonaws.com/h2o"
  if (h2oMajorName == "master") {
    return "${prefix}/master/${suffix}"
  } else {
    return "${prefix}/rel-${h2oMajorName}/${suffix}"
  }
}

static def downloadH2OWheel(String url, File out) {
  if (!out.parentFile.exists()) {
    out.parentFile.mkdirs()
  }

  if (!out.exists()) {
    new URL(url).withInputStream { i -> out.withOutputStream { it << i } }
  }
}

//
// Initial task checking setup of all properties required
// by Python build
//
task checkPythonEnv {
  doLast {
    def H2O_HOME = System.getenv("H2O_HOME")
    def H2O_DRIVER_JAR = System.getenv("H2O_DRIVER_JAR")

    if (H2O_HOME == null) {
      downloadH2OWheel(h2oPythonWheelPackageLocation(), wheelFile)
    } else {
      logger.info("Using \"H2O_HOME\" to specify H2O python package location!")
    }

    // if the spark.ext.h2o.backend.cluster.mode is set to external, then
    // we need to have also H2O_DRIVER_JAR property set in order to be able to perform tests
    if (detectBackendClusterMode() == "external" && H2O_DRIVER_JAR == null) {
      throw new InvalidUserDataException("""When running tests on external H2O cluster, H2O_DRIVER_JAR property is required.
Download H2O driver for the corresonding hadoop distribution via the shell script ``./bin/get-h2o-driver.sh`` and
and please set it, for example as:

export H2O_DRIVER_JAR=/path/to/h2o-driver.jar
                                  """)
    }
  }
}

def copyPySetup() {

  copy {
    from("$projectDir/src") {
      include 'setup.py'
    }
    filter {
      it.replaceAll("SUBST_SPARK_MAJOR_VERSION", sparkMajorVersion)
        .replaceAll("SUBST_SPARK_VERSION", sparkVersion)
        .replaceAll("SUBST_SW_VERSION", version.substring(0, version.lastIndexOf("-")).replace("-", "_"))
        .replaceAll("SUBST_SPARK_MAJOR_VERSION", sparkMajorVersion)
        .replaceAll("SUBST_PYTHON_VERSIONS", convertSupportedPythonVersionsToPyPiDefinitions(supportedPythonVersions))
    }
    from("$projectDir") {
      include 'README.rst'
    }
    from("$projectDir/src") {
      include 'MANIFEST.in'
      include 'setup.cfg'
      include 'pysparkling/**/*'
      include 'ai/**/*'
      exclude '**/*.pyc'
    }
    from("$rootDir/py-scoring/src") {
      include 'ai/h2o/sparkling/**/*'
      include 'pysparkling/**/*'
      exclude 'ai/h2o/sparkling/ml/__init__.py'
      exclude 'pysparkling/ml/__init__.py'
      exclude 'ai/h2o/sparkling/__init__.py'
      exclude 'ai/h2o/sparkling/BackingJar.py'
      exclude 'pysparkling/__init__.py'
      exclude '**/*.pyc'
    }
    from("$projectDir/src-gen") {
      include 'ai/**/*'
      exclude '**/*.pyc'
    }
    into pkgDir
    duplicatesStrategy DuplicatesStrategy.WARN
  }

  copy {
    from("$projectDir/conda/h2o_pysparkling_SUBST_SPARK_MAJOR_VERSION") {
      include 'bld.bat'
      include 'build.sh'
    }
    from("$projectDir/conda/h2o_pysparkling_SUBST_SPARK_MAJOR_VERSION") {
      include 'meta.yaml'
    }
    filter {
      it.replaceAll("SUBST_SPARK_MAJOR_VERSION", sparkMajorVersion)
        .replaceAll("SUBST_SPARK_VERSION", sparkVersion)
        .replaceAll("SUBST_SW_VERSION", version.substring(0, version.lastIndexOf("-")).replace("-", "_"))
    }
    into condaDir
    duplicatesStrategy DuplicatesStrategy.WARN
  }

}


def copyH2OFromH2OHome(String h2oHome) {
  copy {
    from "${h2oHome}/h2o-py/h2o"
    into file("${project.pkgDir}/h2o")
    exclude '**/*.pyc'
    exclude '**/h2o.jar'
    duplicatesStrategy DuplicatesStrategy.WARN
  }
}

def copyH2OFromH2OWheel(File h2oPythonWheel) {
  copy {
    from zipTree(h2oPythonWheel)
    into file("${project.pkgDir}")
    include 'h2o/**'
    exclude '**/*.pyc'
    exclude '**/h2o.jar'
    duplicatesStrategy DuplicatesStrategy.WARN
  }
}

//
// Make PySparkling distribution zip package
//
task distPython(type: Zip, dependsOn: [checkPythonEnv, ':sparkling-water-assembly:shadowJar']) {

  doFirst {
    def H2O_HOME = System.getenv("H2O_HOME")

    // if both properties are set, give precedence to H2O_HOME
    if (H2O_HOME != null) {
      copyH2OFromH2OHome(H2O_HOME)
    } else {
      copyH2OFromH2OWheel(wheelFile)
    }
    // Copy basic python setup
    copyPySetup()
    def replaceStr =
      """
import zipfile
from os import path

if '.zip' in here:
    try:
        with zipfile.ZipFile(path.dirname(here), 'r') as archive:
            __buildinfo__ = archive.read('h2o/buildinfo.txt').decode('utf-8').strip()
    except:
        __buildinfo__ = "unknown"
else:
    try:
        with open(path.join(here, 'buildinfo.txt'), encoding='utf-8') as f:
            __buildinfo__ = f.read().strip()
    except:
         __buildinfo__ = "unknown"

if '.zip' in here:
    try:
        with zipfile.ZipFile(path.dirname(here), 'r') as archive:
            __version__ = archive.read('h2o/version.txt').decode('utf-8').strip()
    except:
        __version__ = "0.0.local"
else:
    try:
        with open(path.join(here, 'version.txt'), encoding='utf-8') as f:
            __version__ = f.read().strip()
    except:
         __version__ = "0.0.local"
                """

    // Change __init__.py in H2O to be aware of being zipped
    def initFile = file("${project.pkgDir}/h2o/__init__.py")
    def initContent = initFile.readLines()
    def lineStart = initContent.findIndexOf { it == "try:" }
    def lineEnd = initContent.findIndexOf { it == "    __version__ = \"0.0.local\"" }
    if (lineStart != -1 && lineEnd != -1) {
      def before = initContent.subList(0, lineStart).join("\n")
      def full = before + replaceStr + initContent.subList(lineEnd + 1, initContent.size()).join("\n")
      initFile.write(full)
    }

    // Copy sparkling water assembly jar
    def fatJar = configurations.sparklingWaterAssemblyJar.singleFile
    copy {
      from fatJar
      into file("${project.pkgDir}/sparkling_water")
      rename ".*", "sparkling_water_assembly.jar"
      duplicatesStrategy DuplicatesStrategy.WARN
    }
    // Save comment into module file
    file("${project.pkgDir}/sparkling_water/").mkdir()
    file("${project.pkgDir}/sparkling_water/__init__.py").write("# Sparkling-water JAR holder for pySparkling module.")
  }
  // Configure proper name
  archiveBaseName = "h2o_pysparkling_${sparkMajorVersion}"

  from pkgDir
  destinationDirectory = distDir
}

configurations {
  sdist
}

artifacts {
  sdist distPython
}

def createUnitTestArgs() {
  return [
    "${distPython.archiveFile.get()}",
    "spark.ext.h2o.backend.cluster.mode=${detectBackendClusterMode()}",
    "spark.ext.h2o.external.disable.version.check=true"
  ]
}

def createIntegTestArgs() {
  return [
    "${distPython.archiveFile.get()}",
    "spark.testing=true",
    "spark.ext.h2o.backend.cluster.mode=${detectBackendClusterMode()}",
    "spark.test.home=${sparkHome}",
    "spark.ext.h2o.log.dir=${buildDir}/h2ologs-itest",
    "spark.ext.h2o.external.disable.version.check=true",
    "spark.ext.h2o.testing.path.to.sw.jar=${configurations.sparklingWaterAssemblyJar.singleFile}"
  ]
}

task cleanPythonTests(type: Delete) {
  delete "${getBuildDir()}/tests"
}

task buildTests(type: Copy, dependsOn: [distPython, cleanPythonTests]) {
  from("tests") {
    include '**/*.*'
  }
  from("../py-scoring/tests") {
    include '**/*.*'
  }
  into "${getBuildDir()}/tests"
  duplicatesStrategy DuplicatesStrategy.WARN
}

task testPythonMojoPipeline(type: PythonTask, dependsOn: buildTests) {
  extraArgs(*createUnitTestArgs())
  def buildDir = getBuildDir()
  command = "${buildDir}/tests/test_runner.py ${buildDir}/tests/unit/with_runtime_spark/test_mojo_pipeline.py"
}

task testPython(type: PythonTask, dependsOn: buildTests) {
  extraArgs(*createUnitTestArgs())
  def buildDir = getBuildDir()
  def tests = "${buildDir}/tests/unit --ignore=${buildDir}/tests/unit/with_runtime_spark/test_mojo_pipeline.py"
  if (project.hasProperty("tests")) {
    tests = project.property("tests").toString()
  }
  command = "${buildDir}/tests/test_runner.py '${tests}'"
}

if (project.property("testMojoPipeline") == "true") {
  testPython.dependsOn testPythonMojoPipeline
}

task integTestPython(type: PythonTask, dependsOn: [buildTests, distPython, checkSparkVersionTask]) {
  extraArgs(*createIntegTestArgs())
  def buildDir = getBuildDir()
  command = "${buildDir}/tests/test_runner.py '${buildDir}/tests/integration --ignore=${buildDir}/tests/integration/external_only'"
}

task integTestPythonExternal(type: PythonTask, dependsOn: [buildTests, distPython, checkSparkVersionTask]) {
  extraArgs(*createIntegTestArgs())
  def buildDir = getBuildDir()
  command = "${buildDir}/tests/test_runner.py ${buildDir}/tests/integration/external_only"
}


//
// Just print location of H2O Python Wheel package with respect to a configured version of H2O dependency
//
task printH2OWheelPackage {
  doLast {
    description = "Print location of H2O Python Wheel package for download"
    println(h2oPythonWheelPackageLocation())
  }
}

//
// Cleanup
//
task cleanPython(type: Delete) {
  delete getBuildDir()
}

task cleanGeneratedApi(type: Delete) {
  delete "$projectDir/src-gen"
}

task generateAlgorithmApi(type: JavaExec, dependsOn: [cleanGeneratedApi, ':sparkling-water-api-generation:build']) {
  group = "Execution"
  classpath = files(* (configurations.apiGeneration.files as List))
  mainClass = "ai.h2o.sparkling.api.generation.AlgorithmAPIRunner"
  args = ["py", "$projectDir/src-gen"]
  standardOutput = System.out
  errorOutput = System.err
}

task generateMOJOApi(type: JavaExec, dependsOn: [cleanGeneratedApi, ':sparkling-water-api-generation:build']) {
  group = "Execution"
  classpath = files(* (configurations.apiGeneration.files as List))
  mainClass = "ai.h2o.sparkling.api.generation.MOJOModelAPIRunner"
  args = ["py", "$projectDir/src-gen"]
  standardOutput = System.out
  errorOutput = System.err
}

task generateConf(type: JavaExec, dependsOn: [cleanGeneratedApi, ':sparkling-water-api-generation:build']) {
  group = "Execution"
  classpath = files(* (configurations.apiGeneration.files as List))
  mainClass = "ai.h2o.sparkling.api.generation.ConfigurationRunner"
  args = ["$projectDir/src-gen/ai/h2o/sparkling", "py"]
  standardOutput = System.out
  errorOutput = System.err
}

//
// Setup execution graph
//
clean.dependsOn cleanPython
clean.dependsOn cleanGeneratedApi
createVersionFile.dependsOn clean
distPython.dependsOn createVersionFile
distPython.dependsOn generateAlgorithmApi
distPython.dependsOn generateMOJOApi
distPython.dependsOn generateConf

build.dependsOn distPython
test.dependsOn testPython

if (detectBackendClusterMode() == "external") {
  integTest.dependsOn integTestPythonExternal
}
integTest.dependsOn integTestPython
