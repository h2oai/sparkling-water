#!/usr/bin/groovy
@Library('test-shared-library') _

// Job parameters
properties(
        [
                parameters(
                        [       string(name: 'releaseFor', defaultValue: 'all', description: "For which Spark Major version" +
                                " do a release. By default, do release for all supported released versions"),
                                booleanParam(name: 'buildConda', defaultValue: true, description: 'Build Conda'),
                                booleanParam(name: 'publishToNexus', defaultValue: true, description: 'Publish to Nexus'),
                                booleanParam(name: 'buildExtendedH2OJars', defaultValue: true, description: 'Build extended H2O Jars'),
                                booleanParam(name: 'publishToS3', defaultValue: true, description: 'Publish to S3'),
                                booleanParam(name: 'updateDocLinks', defaultValue: true, description: 'Update documentation links'),
                                booleanParam(name: 'publishToPiPy', defaultValue: true, description: 'Publish to PiPy'),
                                booleanParam(name: 'publishConda', defaultValue: true, description: 'Publish to Conda'),
                                booleanParam(name: 'releaseOnGithub', defaultValue: true, description: 'Release on Github')
                        ]
                )
        ]
)

//
// Utility methods for the pipeline
//

def getBranch(params) {
    return "${BRANCH_NAME}-${params.spark}".replaceAll("/", "-")
}

def getParallelStageDefinition(params){
    return {
        stage ("Spark ${params.spark}") {
            node('master') {
                docker.withRegistry("http://harbor.h2o.ai") {
                    ansiColor('xterm') {
                        timestamps {
                            ws("${env.WORKSPACE}-spark-${params.spark}") {

                                cleanWs()
                                checkout scm
                                withDocker {
                                    build()(params)
                                    buildConda()(params)
                                    publishToNexus()(params)
                                    buildExtendedH2OJars()(params)
                                    publishToS3()(params)
                                    updateDocLinks()(params)
                                    publishToPipy()(params)
                                    publishToConda()(params)
                                    updateNextRelVersion()(params)
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

String getDockerImageVersion() {
    def versionLine = readFile("gradle.properties").split("\n").find() { line -> line.startsWith('dockerImageVersion') }
    return versionLine.split("=")[1]
}

def withDocker(code) {
    def image = 'opsh2oai/sparkling_water_tests:' + getDockerImageVersion()
    retryWithDelay(3, 120, {
        withCredentials([usernamePassword(credentialsId: "harbor.h2o.ai", usernameVariable: 'REGISTRY_USERNAME', passwordVariable: 'REGISTRY_PASSWORD')]) {
            sh "docker login -u $REGISTRY_USERNAME -p $REGISTRY_PASSWORD harbor.h2o.ai"
            sh "docker pull harbor.h2o.ai/${image}"
        }
    })
    docker.image(image).inside("--init --privileged --dns 172.16.0.200") {
        code()
    }
}

String getVersion(params) {
    def versionLine = readFile("gradle-spark${params.spark}.properties").split("\n").find() { line -> line.startsWith('version') }
    return versionLine.split("=")[1].replace("-SNAPSHOT", "")
}

String getNextVersion(params) {
    def majorVersion = getMajorVersion(params)
    def patchVersion = getPatchVersion(params)
    return "${majorVersion}.${patchVersion.toInteger() + 1}-SNAPSHOT"
}

String getPreviousPatchVersion(params) {
    return "${getPatchVersion(params).toInteger()}"
}

String getMajorVersion(params) {
    def v = getVersion(params)
    def split = v.split("\\.")
    return "${split[0]}.${split[1]}".toString()
}

String getPatchVersion(params) {
    def v = getVersion(params)
    def split = v.split("\\.")
    return "${split[2]}"
}

def getOrCreatePreviousChangeLog(params, previousPatchVersion) {
    def content
    try {
        def url = "https://h2o-release.s3.amazonaws.com/sparkling-water/${getBranch(params)}/${previousPatchVersion}/doc/_sources/CHANGELOG.rst.txt"
        content = url.toURL().getText()
    } catch (Exception ignored) {
        content = """
Change Log
==========


"""
    }
    writeFile(file: 'CHANGELOG.rst', text: content)
}

def prepareReleaseNotes(params) {
    def version = getVersion(params)
    def patchVersion = getPatchVersion(params)
    def previousPatchVersion = getPreviousPatchVersion(params)
    dir("doc/src/site/sphinx/") {
        getOrCreatePreviousChangeLog(params, previousPatchVersion)

        sh """
            # Get ID of this release
            jira_version_id=\$(curl --silent "https://0xdata.atlassian.net/rest/api/2/project/SW/versions" | tr '}' '\\n' | grep "\\"name\\":\\"${version}\\"" | cut -d'"' -f8)
            # Get the JIRA page (currently, there is no endpoint for release notes)
            release_notes_page="https://0xdata.atlassian.net/secure/ReleaseNote.jspa?projectId=12000&version=\${jira_version_id}"
        
            # Obtain the release notes and process them so they look like we expect
            curl --silent "\$release_notes_page" | sed '/<body>/,/<a name="editarea"><\\/a>/!d;//D' | sed 's/<ul>//' | sed 's/<\\/ul>//' | sed 's/ *<h2>/-  /' | sed 's/<\\/h2>//'  | sed 's/<\\/li>//' | sed "s/ *<li>\\[<a href='https:\\/\\/0xdata.atlassian.net\\/browse\\/SW-\\([0-9]*\\)'>SW-[0-9]*<\\/a>\\]/\\   -  \\`SW-\\1 <https:\\/\\/0xdata.atlassian.net\\/browse\\/SW-\\1>\\`__/" | sed '\$ d' | sed '1d' > release_notes

            release_date=\$(date +%Y-%m-%d)
            rel_prefix=\$(echo "v${version} (\$release_date)")
            underscores=\$(head -c \${#rel_prefix} < /dev/zero | tr '\\0' '-')
            download_line="Download at: \\`http://h2o-release.s3.amazonaws.com/sparkling-water/${getBranch(params)}/${patchVersion}/index.html <http://h2o-release.s3.amazonaws.com/sparkling-water/${getBranch(params)}/${patchVersion}/index.html>\\`__"
        
            # Insert release info
            sed -i "4i \$rel_prefix" CHANGELOG.rst
        
            # Insert the underscores
            sed -i "5i \$underscores" CHANGELOG.rst
        
            # Insert the download link
            sed -i "6i \$download_line" CHANGELOG.rst
        
            # Insert the release notes
            sed -i "6r release_notes" CHANGELOG.rst
        
            rm -rf release_notes
            """
    }
}

//
// Main entry point to the pipeline and definition of all stages
//

def sparkMajorVersions
node("master") {
    cleanWs()
    checkout scm
    def versionLine = readFile("gradle.properties")
            .split("\n").find() { line -> line.startsWith('supportedSparkVersions') }
    sparkMajorVersions = versionLine.split("=")[1].split(" ")
}


if (params.releaseFor.toString() != "all") {
    sparkMajorVersions = [params.releaseFor]
}

parallelStages = [:]
sparkMajorVersions.each { version ->
    config = [:]
    params.each { k, v -> config[k] = v }
    config["spark"] = version
    parallelStages["Spark ${version}"] = getParallelStageDefinition(config.clone())
}

parallel(parallelStages)

def build() {
    return { params ->
        stage('Build') {
            withCredentials([usernamePassword(credentialsId: "LOCAL_NEXUS", usernameVariable: 'LOCAL_NEXUS_USERNAME', passwordVariable: 'LOCAL_NEXUS_PASSWORD'),
                             usernamePassword(credentialsId: "SIGNING_KEY", usernameVariable: 'SIGN_KEY', passwordVariable: 'SIGN_PASSWORD'),
                             file(credentialsId: 'release-secret-key-ring-file', variable: 'RING_FILE_PATH')]) {

                prepareReleaseNotes(params)
                sh """
                    activate_java_8
                    ./gradlew dist -Pspark=${params.spark} -Pversion=${getVersion(params)} -PlocalNexusUsername=$LOCAL_NEXUS_USERNAME -PlocalNexusPassword=$LOCAL_NEXUS_PASSWORD -PdoRelease -Psigning.keyId=${SIGN_KEY} -Psigning.secretKeyRingFile=${RING_FILE_PATH} -Psigning.password=
                    # Remove sources of update changelog as after dist, it is alrady part generated web page
                    rm -rf doc/src/site/sphinx/CHANGELOG.rst
                    """
            }
        }
    }
}

def buildConda() {
    return { params ->
        stage('Build Conda Packages') {
            if (params.buildConda.toBoolean()) {
                def majorVersion = getMajorVersion(params)
                dir("py/build/conda") {
                    def pythonVersions = ['2.7', '3.6']
                    for (pyVersion in pythonVersions) {
                        sh """
                           . /envs/h2o_env_python3.6/bin/activate

                           conda build h2o_pysparkling_${majorVersion} --output-folder "." --no-anaconda-upload --py ${pyVersion}

                           PACKAGE_PATH=\$(conda build h2o_pysparkling_${majorVersion} --py ${pyVersion} --output-folder "." --output | tail -1)
                           CURRENT_PLATFORM=\$(basename \$(dirname \$PACKAGE_PATH))
                           mkdir -p ../../../dist/build/dist/py/conda/\$CURRENT_PLATFORM
                           cp \$PACKAGE_PATH ../../../dist/build/dist/py/conda/\$CURRENT_PLATFORM/

                           conda convert \$PACKAGE_PATH -p linux-32 -o ../../../dist/build/dist/py/conda/
                           conda convert \$PACKAGE_PATH -p linux-64 -o ../../../dist/build/dist/py/conda/
                           conda convert \$PACKAGE_PATH -p win-32 -o ../../../dist/build/dist/py/conda/
                           conda convert \$PACKAGE_PATH -p win-64 -o ../../../dist/build/dist/py/conda/
                           conda convert \$PACKAGE_PATH -p osx-64 -o ../../../dist/build/dist/py/conda/
                           """
                    }
                }
            }
        }
    }
}

def publishToNexus() {
    return { params ->
        stage('Publish to Nexus') {
            if (params.publishToNexus.toBoolean()) {
                withCredentials([usernamePassword(credentialsId: "PUBLIC_NEXUS", usernameVariable: 'NEXUS_USERNAME', passwordVariable: 'NEXUS_PASSWORD')]) {
                    sh "./gradlew -Pspark=${params.spark} -Pversion=${getVersion(params)} -PnexusUsername=${NEXUS_USERNAME} -PnexusPassword=${NEXUS_PASSWORD} publishToNexus -x check"
                }
            }
        }
    }
}

def buildExtendedH2OJars() {
    return { params ->
        stage('Build Extended H2O Jars') {
            if (params.buildExtendedH2OJars.toBoolean()) {
                sh """
                    # Create extended H2O jar for all supported hadoop distributions
                    HADOOP_DISTRIBUTIONS=`./gradlew -Pversion=${getVersion(params)} -Dorg.gradle.internal.launcher.welcomeMessageEnabled=false -q :sparkling-water-assembly-h2o:printHadoopDistributions)`
                    for distro in \${HADOOP_DISTRIBUTIONS}
                    do
                      ./gradlew -Pspark=${params.spark} -Pversion=${getVersion(params)} -PdoExtend extendJar -PdownloadH2O="\${distro}"
                    done
                    # Create extended H2O jar also for the regular h2o (no H2O driver)
                    ./gradlew -Pspark=${params.spark} -Pversion=${getVersion(params)} -PdoExtend extendJar -PdownloadH2O
                    
                    # Copy to directory which is uploaded to S3
                    cp -R assembly-h2o/private/extended dist/build/dist/
                    """
            }
        }
    }
}

def publishToS3() {
    return { params ->
        stage('Publish to S3') {
            if (params.publishToS3.toBoolean()) {
                def patchVersion = getPatchVersion(params)
                withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'AWS S3 Credentials', accessKeyVariable: 'AWS_ACCESS_KEY_ID', secretKeyVariable: 'AWS_SECRET_ACCESS_KEY']]) {
                    sh """
                        export AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}
                        export AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}
                        ~/.local/bin/aws s3 sync dist/build/dist s3://h2o-release/sparkling-water/${getBranch(params)}/${patchVersion} --acl public-read

                        echo UPDATE LATEST POINTER
                        echo ${patchVersion} > latest
                        echo "<head>" > latest.html
                        echo "<meta http-equiv=\\"refresh\\" content=\\"0; url=${patchVersion}/index.html\\" />" >> latest.html
                        echo "</head>" >> latest.html

                        ~/.local/bin/aws s3 cp latest s3://h2o-release/sparkling-water/${getBranch(params)}/latest --acl public-read
                        ~/.local/bin/aws s3 cp latest.html s3://h2o-release/sparkling-water/${getBranch(params)}/latest.html --acl public-read
                        ~/.local/bin/aws s3 cp latest.html s3://h2o-release/sparkling-water/${getBranch(params)}/index.html --acl public-read
                        """
                }
            }
        }
    }
}

def updateDocLinks() {
    return { params ->
        stage('Update Documentation Links') {
            if (params.updateDocLinks.toBoolean()) {
                withCredentials([file(credentialsId: 'master-id-rsa', variable: 'ID_RSA_PATH'), file(credentialsId: 'master-gitconfig', variable: 'GITCONFIG_PATH'), string(credentialsId: 'h2o-ops-personal-auth-token', variable: 'GITHUB_TOKEN'), sshUserPrivateKey(credentialsId: 'h2oOpsGitPrivateKey', keyFileVariable: 'SSH_KEY_GITHUB')]) {

                    sh """
                               # Copy keys
                               rm -rf ~/.ssh ~/.gitconfig
                               mkdir -p ~/.ssh
                               cp \${ID_RSA_PATH} ~/.ssh/id_rsa
                               cp \${GITCONFIG_PATH} ~/.gitconfig

cat <<EOF >>  ~/.ssh/config
Host github.com
   HostName github.com
   User git
   IdentityFile \${SSH_KEY_GITHUB}
   IdentitiesOnly yes
EOF

                                ssh-keyscan github.com >> ~/.ssh/known_hosts
                               """

                    def majorVersion = getMajorVersion(params)
                    def patchVersion = getPatchVersion(params)
                    retryWithDelay(3, 120, {
                        sh """
                                rm -rf docs.h2o.ai
                                git clone git@github.com:h2oai/docs.h2o.ai.git
                                cd docs.h2o.ai/sites-available/
                                sed -i.backup -E "s?http://h2o-release.s3.amazonaws.com/sparkling-water/${getBranch(params)}/[0-9]+/?http://h2o-release.s3.amazonaws.com/sparkling-water/${getBranch(params)}/${patchVersion}/?" 000-default.conf
                                git add 000-default.conf
                                git commit -m "Update links of Sparkling Water ${majorVersion} version to ${patchVersion}"
                                git push --set-upstream origin master
                                cd ../..
                            """
                    })
                }
            }
        }
    }
}

def publishToPipy() {
    return { params ->
        stage('Publish to PiPy') {
            if (params.publishToPiPy.toBoolean()) {
                dir("py/build/pkg") {
                    withCredentials([usernamePassword(credentialsId: "pypi-credentials", usernameVariable: 'PIPY_USERNAME', passwordVariable: 'PIPY_PASSWORD')]) {
                        sh """
                            . /envs/h2o_env_python3.6/bin/activate
                            python setup.py sdist
                            twine upload dist/* -u $PIPY_USERNAME -p $PIPY_PASSWORD
                            """
                    }
                }
            }
        }
    }
}

def publishToConda() {
    return { params ->
        stage('Publish to Conda') {
            if (params.buildConda.toBoolean() && params.publishConda.toBoolean()) {
                def majorVersion = getMajorVersion(params)
                dir("py/build/conda") {
                    withCredentials([usernamePassword(credentialsId: 'anaconda-credentials', usernameVariable: 'ANACONDA_USERNAME', passwordVariable: 'ANACONDA_PASSWORD')]) {
                        def pythonVersions = ['2.7', '3.6']
                        for (pyVersion in pythonVersions) {
                            sh """
            
                                CONDA_PKG_CURRENT_ARCH_PATH=\$(conda build h2o_pysparkling_${majorVersion} --py ${pyVersion} --output-folder "." --output | tail -1)
                                PKG_NAME=\$(basename \$CONDA_PKG_CURRENT_ARCH_PATH)

                                # Upload Conda packages of PySparkling
                                yes | anaconda login --username ${ANACONDA_USERNAME} --password ${ANACONDA_PASSWORD}

                                anaconda upload --force ../../../dist/build/dist/py/conda/osx-64/\${PKG_NAME}
                                anaconda upload --force ../../../dist/build/dist/py/conda/linux-32/\${PKG_NAME}
                                anaconda upload --force ../../../dist/build/dist/py/conda/linux-64/\${PKG_NAME}
                                anaconda upload --force ../../../dist/build/dist/py/conda/win-32/\${PKG_NAME}
                                anaconda upload --force ../../../dist/build/dist/py/conda/win-64/\${PKG_NAME}
                                """
                        }
                    }
                }
            }
        }
    }
}

def updateNextRelVersion() {
    return { params ->
        stage('Update Next Release Version') {
            if (params.releaseOnGithub.toBoolean()) {
                withCredentials([file(credentialsId: 'master-id-rsa', variable: 'ID_RSA_PATH'), file(credentialsId: 'master-gitconfig', variable: 'GITCONFIG_PATH'), string(credentialsId: 'h2o-ops-personal-auth-token', variable: 'GITHUB_TOKEN')]) {
                    sh """
                        # Copy keys
                        rm -rf ~/.ssh ~/.gitconfig
                        mkdir -p ~/.ssh
                        cp \${ID_RSA_PATH} ~/.ssh/id_rsa
                        cp \${GITCONFIG_PATH} ~/.gitconfig
                        """

                    def version = getVersion(params)
                    def nextVersion = getNextVersion(params)
                    retryWithDelay(6, 10, {
                        sh """
                        git config remote.origin.url "https://${GITHUB_TOKEN}@github.com/h2oai/sparkling-water.git"
                        git pull
                        if git tag --list | grep -q RELEASE-${version}; then git tag -d RELEASE-${version}; fi
                        if git ls-remote --tags origin | grep -q RELEASE-${version}; then git push --delete origin RELEASE-${version}; fi
                        ./gradlew -Pspark=${params.spark} -Prelease.useAutomaticVersion=true -Prelease.releaseVersion=${version} -Prelease.newVersion=${nextVersion} -PdoRelease release -x check
                        """
                    })
                }
            }
        }
    }
}
